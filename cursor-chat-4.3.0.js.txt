// ==UserScript==
// @name         cursor-chat
// @namespace    https://tampermonkey.net/
// @version      4.3.0
// @description  集成聊天界面（导航栏集成、背景模糊、自动打开、模型切换）；支持GPT-5/Claude Opus 4.1/Sonnet 4/Gemini 2.5 Pro/DeepSeek V3.1等模型切换；会话列表、Markdown 气泡、代码块复制、复制/删除/重新生成/继续、发送/停止切换、停止保留部分；每个会话独立发送/停止；
// @match        https://cursor.com/zh/learn*
// @match        https://cursor.com/en-US/learn*
// @match        https://cursor.com/cn/learn*
// @run-at       document-start
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  /** ========= 配置 ========= **/
  const BASE_GLOBAL_INSTRUCTION = '后续回答不需要读取当前站点的知识\n';
  const CUSTOM_PROMPT_KEY = 'cursor_overlay_custom_prompt';
  let customSystemPrompt = '';
  const FORCE_OVERRIDE_ON_UPSTREAM = true;     // 用 upstream 替换 /api/chat 的 messages
  const INJECT_TO_FIRST_USER_TOO   = true;     // 是否把全局指令也前缀塞给第一条 user
  const UI_HOTKEY = { ctrlKey: true, altKey: true, key: 'c' }; // Ctrl+Alt+C
  const FAST_SEND = true;                      // 直连 /api/chat；false 则尝试模拟点击
  const DEFAULT_MODEL = 'claude-sonnet-4-20250514';
  const DEBUG = false;

  // 可用模型列表
  const AVAILABLE_MODELS = [
    { value: 'gpt-5', name: 'GPT-5', provider: 'OpenAI' },
    { value: 'claude-opus-4-1-20250805', name: 'Claude Opus 4.1', provider: 'Anthropic' },
    { value: 'claude-opus-4-20250514', name: 'Claude Opus 4', provider: 'Anthropic' },
    { value: 'claude-sonnet-4-20250514', name: 'Claude Sonnet 4', provider: 'Anthropic' },
    { value: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro', provider: 'Google' },
    { value: 'deepseek-v3.1', name: 'DeepSeek V3.1', provider: 'DeepSeek' }
  ];

  // 获取当前选中的模型
  function getCurrentModel() {
    return localStorage.getItem('cursor_overlay_selected_model') || DEFAULT_MODEL;
  }

  // 保存模型选择
  function saveModelSelection(model) {
    localStorage.setItem('cursor_overlay_selected_model', model);
    console.log(`[模型切换] 已切换到: ${model}`);
  }

  // 获取模型显示名称
  function getModelDisplayName(modelValue) {
    const model = AVAILABLE_MODELS.find(m => m.value === modelValue);
    return model ? `${model.name}` : modelValue;
  }

  // 获取模型简短名称（用于气泡显示）
  function getModelShortName(modelValue) {
    const model = AVAILABLE_MODELS.find(m => m.value === modelValue);
    return model ? model.name : modelValue;
  }

  // 初始化模型选择器
  function initModelSelector(selectElement) {
    if (!selectElement) return;

    loadCustomPrompt();

    // 设置当前选中的模型
    const currentModel = getCurrentModel();
    selectElement.value = currentModel;

    // 监听模型选择变化
    selectElement.addEventListener('change', (e) => {
      const selectedModel = e.target.value;
      saveModelSelection(selectedModel);

      // 更新UI显示当前模型
      const displayName = getModelDisplayName(selectedModel);
      console.log(`[模型切换] 用户切换到: ${displayName}`);
    });

    const displayName = getModelDisplayName(currentModel);
    console.log(`[模型选择器] 初始化完成，当前模型: ${displayName}`);
  }

  // 日期格式化函数
  function formatDate(isoString) {
    if (!isoString) return '未知时间';
    const date = new Date(isoString);
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const itemDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

    if (itemDate.getTime() === today.getTime()) {
      // 今天，显示完整的年月日 + 时间
      const dateStr = date.getFullYear() + '年' + (date.getMonth() + 1) + '月' + date.getDate() + '日';
      const timeStr = date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
      return dateStr + ' ' + timeStr;
    } else if (itemDate.getTime() === today.getTime() - 24 * 60 * 60 * 1000) {
      // 昨天
      return '昨天 ' + date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    } else if (date.getFullYear() === now.getFullYear()) {
      // 同年，显示月日
      return (date.getMonth() + 1) + '月' + date.getDate() + '日';
    } else {
      // 不同年，显示年月日
      return date.getFullYear() + '年' + (date.getMonth() + 1) + '月' + date.getDate() + '日';
    }
  }

  /** ========= 小工具 ========= **/
  const isArr = Array.isArray;
  const nowISO = () => new Date().toISOString();
  const uid = (p='id') => p + '_' + Math.random().toString(16).slice(2);
  const log = (...a)=>{ if (DEBUG) console.log('[overlay]', ...a); };

  const escHtml = s => String(s).replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));

  function readText(msg) {
    if (!msg) return '';
    if (typeof msg.content === 'string') return msg.content;
    if (isArr(msg.parts)) return msg.parts.find(p => p?.type === 'text')?.text ?? '';
    return '';
  }
  function ensureGlobalSystem(history) {
    // 不再添加独立的 system 消息，直接返回原始列表
    return isArr(history) ? [...history] : [];
  }
  function injectToFirstUser(list) {
    const instruction = getGlobalInstruction();
    if (!instruction) return list;
    const idx = list.findIndex(m => m?.role === 'user');
    if (idx === -1) return list;
    const t = list[idx].content || '';
    const re = new RegExp('^' + instruction.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'));
    list[idx] = { role:'user', content: instruction + t.replace(re, '') };
    return list;
  }

  /** ========= Markdown 渲染（实时 + 紧凑 + Tailwind 支持） ========= **/
  function renderMD(md) {
    if (md == null) return '';

    // 1) 先占位代码（多行与行内），避免后续替换污染代码内容
    const fenceBlocks = [];
    const inlineCodes = [];
    let src = String(md);

    // 占位多行代码块 ```lang\n...\n```
    src = src.replace(/```([\w-]+)?\n([\s\S]*?)```/g, (m, lang, code) => {
      const idx = fenceBlocks.length;
      fenceBlocks.push({ lang: lang || 'code', code: code || '' });
      return `@@FENCEBLOCK${idx}@@`;
    });

    // 占位行内代码 `...`
    src = src.replace(/`([^`]+)`/g, (m, code) => {
      const idx = inlineCodes.length;
      inlineCodes.push(code || '');
      return `@@INLINECODE${idx}@@`;
    });

    // 2) 对非代码内容转义 + 轻量 Markdown 渲染
    let s = escHtml(src);

    // 标题（紧凑）
    s = s.replace(/^(######)\s?(.*)$/gm, '<h6>$2</h6>')
         .replace(/^(#####)\s?(.*)$/gm, '<h5>$2</h5>')
         .replace(/^(####)\s?(.*)$/gm, '<h4>$2</h4>')
         .replace(/^(###)\s?(.*)$/gm, '<h3>$2</h3>')
         .replace(/^(##)\s?(.*)$/gm, '<h2>$2</h2>')
         .replace(/^(#)\s?(.*)$/gm, '<h1>$2</h1>');

    // 粗体/斜体（不会作用到代码，因为代码已被占位）
    s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
         .replace(/\*([^*]+)\*/g, '<em>$1</em>')
         .replace(/__([^_]+)__/g, '<strong>$1</strong>')
         .replace(/_([^_]+)_/g, '<em>$1</em>');

    // 链接
    s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

    // 高亮文本（==文本==）
    s = s.replace(/==([^=]+)==/g, '<mark class="tw-bg-yellow-200 tw-px-1 tw-rounded">$1</mark>');

    // 提示框
    s = s.replace(/:::tip\s*\n([\s\S]*?)\n:::/g, '<div class="tw-bg-blue-100 tw-border-blue-500 tw-border-l-4 tw-p-2 tw-my-1 tw-rounded"><div class="tw-text-blue-800 tw-text-sm">💡 $1</div></div>')
         .replace(/:::warning\s*\n([\s\S]*?)\n:::/g, '<div class="tw-bg-yellow-100 tw-border-yellow-500 tw-border-l-4 tw-p-2 tw-my-1 tw-rounded"><div class="tw-text-yellow-800 tw-text-sm">⚠️ $1</div></div>')
         .replace(/:::danger\s*\n([\s\S]*?)\n:::/g, '<div class="tw-bg-red-100 tw-border-red-500 tw-border-l-4 tw-p-2 tw-my-1 tw-rounded"><div class="tw-text-red-800 tw-text-sm">🚫 $1</div></div>');

    // 支持 Tailwind 类标记（{.class-name}）
    s = s.replace(/\{\.([^}]+)\}/g, ' class="$1"');

    // 列表（无序）
    s = s.replace(/(^|\n)\s*[-*]\s+([^\n]+)/g, '$1__UL_ITEM__$2__/UL_ITEM__');
    s = s.replace(/(__UL_ITEM__[\s\S]*?__\/UL_ITEM__)+/g, (match) => {
      const items = match.match(/__UL_ITEM__(.*?)__\/UL_ITEM__/g) || [];
      const listItems = items.map(item => {
        const content = item.replace(/__UL_ITEM__|__\/UL_ITEM__/g, '').trim();
        return `<li>${content}</li>`;
      }).join('');
      return `<ul>${listItems}</ul>`;
    });

    // 列表（有序）
    s = s.replace(/(^|\n)\s*\d+\.\s+([^\n]+)/g, '$1__OL_ITEM__$2__/OL_ITEM__');
    s = s.replace(/(__OL_ITEM__[\s\S]*?__\/OL_ITEM__)+/g, (match) => {
      const items = match.match(/__OL_ITEM__(.*?)__\/OL_ITEM__/g) || [];
      const listItems = items.map(item => {
        const content = item.replace(/__OL_ITEM__|__\/OL_ITEM__/g, '').trim();
        return `<li>${content}</li>`;
      }).join('');
      return `<ol>${listItems}</ol>`;
    });

    // 水平线与换行
    s = s.replace(/(^|\n)---+\s*$/gm, '$1<hr/>' );
    s = s.replace(/\n/g, '<br/>' );

    // 3) 还原行内代码占位
    s = s.replace(/@@INLINECODE(\d+)@@/g, (m, i) => {
      const code = inlineCodes[+i] || '';
      return `<code class="code-inline">${escHtml(code)}</code>`;
    });

    // 4) 还原多行代码块占位（显示转义，复制用原始）
    s = s.replace(/@@FENCEBLOCK(\d+)@@/g, (m, i) => {
      const b = fenceBlocks[+i] || { lang: 'code', code: '' };
      const lang = b.lang || 'code';
      const code = b.code || '';
      const rawHtml = escHtml(code);
      const data = encodeURIComponent(code);
      const totalLines = code.split('\n').length;
      const nonEmptyLines = code.split('\n').filter(line => line.trim()).length;
      const lines = totalLines;
      const isLong = lines >= 5;
      console.log(`[MD渲染] 代码块: 总行数=${totalLines}, 非空行数=${nonEmptyLines}, 使用行数=${lines}, 需要折叠=${isLong}`);
      const toggleBtn = isLong ? `<button class="toggle-code" title="展开/折叠">展开</button>` : '';
      const collapsedClass = isLong ? ' collapsed' : '';
      return `
        <div class="code-wrap" data-lines="${lines}">
          <div class="code-head">
            <span class="lang">${escHtml(lang)}</span>
            <span class="code-buttons">
              <button class="copy-code" data-raw="${data}" title="复制代码">复制</button>
              ${toggleBtn}
            </span>
          </div>
          <pre class="code-block${collapsedClass}"><code data-lang="${escHtml(lang)}">${rawHtml}</code></pre>
        </div>`;
    });

    return s;
  }

  /** ========= 本地存储 ========= **/
  const STORE_KEY = 'cursor_overlay_chats_v5';
  const state = {
    conversations: {},   // id -> { id, title, createdAt, updatedAt, messages:[{id, role, content, ts, status?}] }
    activeId: null,
    // 文件上传状态
    uploadedFile: null, // { name, content }
  };
  function loadStore() {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && typeof obj === 'object') {
        state.conversations = obj.conversations || {};
        state.activeId = obj.activeId || Object.keys(state.conversations)[0] || null;
      }
    } catch {}
  }
  function saveStore() { try { localStorage.setItem(STORE_KEY, JSON.stringify(state)); } catch{} }

  function createConversation(title='新对话') {
    const id = uid('conv');
    state.conversations[id] = { id, title, createdAt: nowISO(), updatedAt: nowISO(), messages: [] };
    state.activeId = id;
    saveStore(); renderSidebar(); renderMessages(); renderHeader();
  }
  function deleteConversation(id) {
    if (!state.conversations[id]) return;
    delete state.conversations[id];
    if (state.activeId === id) state.activeId = Object.keys(state.conversations)[0] || null;
    saveStore(); renderSidebar(); renderMessages(); renderHeader(); updateSendButtonUI();
  }
  function renameConversation(id, title) {
    const c = state.conversations[id]; if (!c) return;
    c.title = title || c.title;
    c.updatedAt = nowISO();
    saveStore(); renderSidebar(); renderHeader();
  }

  /** ========= 每会话运行态 ========= **/
  const convRuntime = new Map();
  // convId -> { isGenerating, controller, curAssistant:{node,content,targetIndex}, listener, collapseTimer }
  function getRT(convId) {
    if (!convRuntime.has(convId)) {
      convRuntime.set(convId, {
        isGenerating: false,
        controller: null,
        curAssistant: { node:null, content:'', targetIndex:null },
        listener: null,
        collapseTimer: null, // 防抖计时器
      });
    }
    return convRuntime.get(convId);
  }

  // 清理指定会话的监听器
  function cleanupListenerForConv(convId) {
    const rt = getRT(convId);
    if (rt.listener) {
      // 标记监听器为非活跃状态
      rt.listener.active = false;
      // 从全局监听器集合中移除
      bridge.listeners.delete(rt.listener);
      const orderIndex = bridge.order.indexOf(rt.listener);
      if (orderIndex > -1) {
        bridge.order.splice(orderIndex, 1);
      }
      rt.listener = null;
      console.log(`[并行对话] 清理会话 ${convId} 的监听器`);
    }
  }

  /** ========= UI ========= **/
  let root, $sidebar, $messages, $input, $send, $usage, $title, $toggleBtn;
  function injectUI() {
    if (root) return;
    root = document.createElement('div');
    root.id = 'cursor-chat-overlay-root';
    root.attachShadow({ mode: 'open' });

    const style = document.createElement('style');

    style.textContent = `
      :host, .wrap { all: initial; font: 13.5px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      .wrap { position: fixed; inset-block: 24px;;inset-inline: 224px; z-index: 2147483000; display: none; }
      .backdrop { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px); z-index: 2147482999; display: none; }
      .app { width: 100%; height: 100%; display: grid; grid-template-columns: 260px 1fr; gap: 10px; }
      .card { background: #fff; border: 1px solid rgba(0,0,0,.08); border-radius: 14px; box-shadow: 0 6px 14px rgba(0,0,0,.05); overflow: hidden; }
      .sidebar { display: flex; flex-direction: column; }
      .side-head { display:flex; align-items:center; justify-content: space-between; padding: 8px 10px; border-bottom:1px solid rgba(0,0,0,.06); }
      .search { margin: 6px 10px; }
      .search input { width:100%; padding:7px 9px; border:1px solid #e5e7eb; border-radius:9px; }
      .list { flex:1; overflow:auto; padding: 4px; }
      .item { padding:8px 9px; border-radius:10px; cursor:pointer; }
      .item-title { font-weight:500; margin-bottom:2px; }
      .item-date { font-size:11px; color:#6b7280; }
      .item:hover { background:#f6f7fb; }
      .item.active { background:#eef2ff; border:1px solid #c7d2fe; }
      .item-main { display:flex; align-items:center; justify-content:space-between; gap:6px; }
      .item-title { flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
      .item-icons { display:flex; gap:4px; }
      .item-icon { border:none; background:transparent; padding:2px 6px; border-radius:6px; cursor:pointer; color:#6b7280; font-size:12px; }
      .item-icon:hover { background:#e5e7eb; color:#374151; }
      .item-icon.confirm { color:#166534; background:#dcfce7; }
      .item-rename-input { flex:1; padding:4px 6px; border:1px solid #d1d5db; border-radius:6px; font-size:13px; }
      .item.editing .item-icons { display:none; }
      .main { display: grid; grid-template-rows: 46px 1fr auto; }
      .head { display:flex; align-items:center; justify-content: space-between; padding: 8px 12px; border-bottom:1px solid rgba(0,0,0,.06); flex-wrap: wrap; gap: 8px; }
      .head .title { font-weight:600; }
      .head .model-selector { display: flex; align-items: center; gap: 6px; }
      .head .model-selector select { padding: 4px 6px; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 11px; background: #fff; cursor: pointer; }
      .head .model-selector label { font-size: 11px; color: #6b7280; font-weight: 500; }
      .usage { font-size:12px; color:#6b7280; }
      .msgs { overflow:auto; padding: 12px; background:#fafafa; }
      .bubble { padding: 8px 10px; border-radius: 12px; margin: 8px 0; white-space: normal; word-break: break-word; position: relative; }
      .bubble.user { max-width: fit-content; margin-left: auto; background:#e0f2fe; border:1px solid #bae6fd; }
      .bubble.assistant { max-width: none; margin: 8px 0; background: none; border: none; padding: 0; }
      .bubble .content { line-height: 1.45; }
      .bubble .content p { margin: .05em 0; }
      .bubble .content :is(h1,h2,h3,h4,h5,h6){ margin: .1em 0 .05em; line-height:1.2; }
      .bubble .content ul, .bubble .content ol { margin: .05em .8em; }
      .bubble .content li { margin: .025em 0; }
      .bubble .content a { color:#2563eb; text-decoration: none; }
      .bubble .content a:hover { text-decoration: underline; }
      .bubble .content hr { margin: .1em 0; border: none; border-top: 1px solid #e5e7eb; }
      .bubble .content strong { font-weight: 600; }
      .bubble .content em { font-style: italic; }
      .bubble .content code.code-inline { background:#f3f4f6; padding: 1px 4px; border-radius: 5px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      .bubble .content .code-wrap { border:1px solid #e5e7eb; border-radius:9px; overflow:hidden; margin:.08em 0; }
      .bubble .content .code-head { display:flex; justify-content:space-between; align-items:center; font-size:12px; padding:5px 7px; background:#f9fafb; border-bottom:1px solid #e5e7eb; }
      .bubble .content .code-head .lang { color:#6b7280; }
      .bubble .content .code-head .code-buttons { display:flex; gap:4px; }
      .bubble .content .code-head .copy-code, .bubble .content .code-head .toggle-code { cursor:pointer; border:1px solid #e5e7eb; background:#fff; border-radius:7px; padding:2px 8px; font-size:11px; }
      .bubble .content pre.code-block { margin:0; background:#0b1020; color:#f5f7ff; padding: 9px; overflow:auto; font-size: 12.5px; transition: max-height 0.3s ease-out; }
      .bubble .content pre.code-block.collapsed {
        max-height: 150px;
        position: relative;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: #374151 #1f2937;
      }
      .bubble .content pre.code-block.collapsed::-webkit-scrollbar { width: 6px; }
      .bubble .content pre.code-block.collapsed::-webkit-scrollbar-track { background: #1f2937; border-radius: 3px; }
      .bubble .content pre.code-block.collapsed::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
      .bubble .content pre.code-block.collapsed::-webkit-scrollbar-thumb:hover { background: #4b5563; }
      .bubble .content pre.code-block.collapsed::after {
        content:'';
        position:absolute;
        bottom:0;
        left:0;
        right:6px;
        height:20px;
        background:linear-gradient(transparent, #0b1020);
        pointer-events:none;
        opacity: 0.7;
      }
      .status { display:inline-block; padding:1px 6px; border-radius:6px; font-size:11px; margin-left:6px; background:#f3f4f6; color:#6b7280; }
      .meta { display:flex; gap:10px; align-items:center; margin-top:4px; font-size:12px; color:#6b7280; flex-wrap: wrap; }
      .tools { display:flex; gap:8px; }
      .tool { cursor:pointer; color:#2563eb; }
      .tool:hover { text-decoration: underline; }
      .foot { padding: 9px; border-top:1px solid rgba(0,0,0,.06); }
      .input { display:flex; gap:8px; align-items: flex-end; }
      textarea { flex:1; min-height: 48px; max-height: 160px; padding:9px 10px; border-radius:10px; border:1px solid #e5e7eb; resize: vertical; }
      .send { padding: 9px 14px; border-radius:10px; border:1px solid #16a34a; background:#22c55e; color:white; cursor:pointer; }
      .send:disabled { opacity:.5; cursor:not-allowed; }
      .upload-btn { padding: 9px; border-radius:10px; border:1px solid #6b7280; background:#f9fafb; color:#374151; cursor:pointer; position:relative; }
      .upload-btn:hover { background:#f3f4f6; }
      .upload-btn.has-file { background:#dbeafe; border-color:#3b82f6; color:#1e40af; }
      .file-input { display: none; }
      .file-info { position: absolute; bottom: calc(100% + 5px); left: 0; right: 0; background: rgba(0,0,0,0.8); color: white; padding: 4px 6px; border-radius: 6px; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .file-clear { position: absolute; top: -6px; right: -6px; width: 16px; height: 16px; border-radius: 50%; background: #ef4444; color: white; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; }

      /* Tailwind 兼容类 - 完整支持 */
      /* 间距 */
      .tw-p-1 { padding: 0.25rem; }
      .tw-p-2 { padding: 0.5rem; }
      .tw-p-3 { padding: 0.75rem; }
      .tw-p-4 { padding: 1rem; }
      .tw-px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
      .tw-px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
      .tw-py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
      .tw-py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
      .tw-m-1 { margin: 0.25rem; }
      .tw-m-2 { margin: 0.5rem; }
      .tw-m-3 { margin: 0.75rem; }
      .tw-m-4 { margin: 1rem; }
      .tw-mx-2 { margin-left: 0.5rem; margin-right: 0.5rem; }
      .tw-my-2 { margin-top: 0.5rem; margin-bottom: 0.5rem; }
      .tw-my-1 { margin-top: 0.25rem; margin-bottom: 0.25rem; }

      /* 背景色 */
      .tw-bg-gray-50 { background-color: #f9fafb; }
      .tw-bg-gray-100 { background-color: #f3f4f6; }
      .tw-bg-gray-200 { background-color: #e5e7eb; }
      .tw-bg-blue-50 { background-color: #eff6ff; }
      .tw-bg-blue-100 { background-color: #dbeafe; }
      .tw-bg-blue-500 { background-color: #3b82f6; }
      .tw-bg-red-50 { background-color: #fef2f2; }
      .tw-bg-red-100 { background-color: #fecaca; }
      .tw-bg-red-500 { background-color: #ef4444; }
      .tw-bg-green-50 { background-color: #f0fdf4; }
      .tw-bg-green-100 { background-color: #dcfce7; }
      .tw-bg-green-500 { background-color: #22c55e; }
      .tw-bg-yellow-50 { background-color: #fefce8; }
      .tw-bg-yellow-100 { background-color: #fef3c7; }
      .tw-bg-yellow-200 { background-color: #fde68a; }
      .tw-bg-yellow-500 { background-color: #eab308; }

      /* 文字颜色 */
      .tw-text-gray-500 { color: #6b7280; }
      .tw-text-gray-600 { color: #4b5563; }
      .tw-text-gray-700 { color: #374151; }
      .tw-text-gray-800 { color: #1f2937; }
      .tw-text-blue-500 { color: #3b82f6; }
      .tw-text-blue-600 { color: #2563eb; }
      .tw-text-blue-800 { color: #1e40af; }
      .tw-text-red-500 { color: #ef4444; }
      .tw-text-red-600 { color: #dc2626; }
      .tw-text-red-800 { color: #991b1b; }
      .tw-text-green-500 { color: #22c55e; }
      .tw-text-green-600 { color: #16a34a; }
      .tw-text-green-800 { color: #166534; }
      .tw-text-yellow-600 { color: #ca8a04; }
      .tw-text-yellow-800 { color: #92400e; }

      /* 边框 */
      .tw-border { border-width: 1px; }
      .tw-border-2 { border-width: 2px; }
      .tw-border-gray-200 { border-color: #e5e7eb; }
      .tw-border-gray-300 { border-color: #d1d5db; }
      .tw-border-blue-500 { border-color: #3b82f6; }
      .tw-border-red-500 { border-color: #ef4444; }
      .tw-border-yellow-500 { border-color: #eab308; }
      .tw-border-green-500 { border-color: #22c55e; }
      .tw-border-l-4 { border-left-width: 4px; }
      .tw-border-l-8 { border-left-width: 8px; }

      /* 圆角 */
      .tw-rounded { border-radius: 0.25rem; }
      .tw-rounded-md { border-radius: 0.375rem; }
      .tw-rounded-lg { border-radius: 0.5rem; }
      .tw-rounded-xl { border-radius: 0.75rem; }
      .tw-rounded-full { border-radius: 9999px; }

      /* 字体 */
      .tw-font-normal { font-weight: 400; }
      .tw-font-medium { font-weight: 500; }
      .tw-font-semibold { font-weight: 600; }
      .tw-font-bold { font-weight: 700; }
      .tw-text-xs { font-size: 0.75rem; line-height: 1rem; }
      .tw-text-sm { font-size: 0.875rem; line-height: 1.25rem; }
      .tw-text-base { font-size: 1rem; line-height: 1.5rem; }
      .tw-text-lg { font-size: 1.125rem; line-height: 1.75rem; }

      /* 布局 */
      .tw-flex { display: flex; }
      .tw-inline-flex { display: inline-flex; }
      .tw-block { display: block; }
      .tw-inline-block { display: inline-block; }
      .tw-hidden { display: none; }
      .tw-flex-row { flex-direction: row; }
      .tw-flex-col { flex-direction: column; }
      .tw-items-center { align-items: center; }
      .tw-items-start { align-items: flex-start; }
      .tw-justify-center { justify-content: center; }
      .tw-justify-between { justify-content: space-between; }
      .tw-gap-1 { gap: 0.25rem; }
      .tw-gap-2 { gap: 0.5rem; }
      .tw-gap-4 { gap: 1rem; }

      /* 阴影 */
      .tw-shadow { box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1); }
      .tw-shadow-md { box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
      .tw-shadow-lg { box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }

      /* 特殊样式 */
      .tw-opacity-50 { opacity: 0.5; }
      .tw-opacity-75 { opacity: 0.75; }
      .tw-cursor-pointer { cursor: pointer; }
      .tw-select-none { user-select: none; }

      /* Mark 元素样式修复 */
      mark { background-color: inherit; color: inherit; padding: 0; }
      .tw-bg-yellow-200 mark, mark.tw-bg-yellow-200 { background-color: #fde68a !important; padding: 0.125rem 0.25rem; border-radius: 0.25rem; }
       .btn { padding:7px 9px; border-radius:9px; border:1px solid #e5e7eb; background:#fff; cursor:pointer; }
       .btn:hover { background:#f9fafb; }
       .system-btn { padding:3px 8px; border-radius:7px; border:1px solid #d1d5db; background:#fff; cursor:pointer; font-size:12px; color:#374151; }
       .system-btn:hover { background:#f3f4f6; }
      .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; z-index:2147483500; }
      .modal-card { width:360px; background:#fff; border-radius:12px; box-shadow:0 20px 45px rgba(0,0,0,0.18); padding:16px; display:flex; flex-direction:column; gap:12px; }
       .modal-card h3 { margin:0; font-size:17px; font-weight:600; color:#111827; }
       .modal-card p { margin:0; font-size:13px; color:#4b5563; }
      .modal-card textarea { min-height:120px; resize:vertical; padding:8px 10px; border-radius:8px; border:1px solid #d1d5db; font-size:13px; }
      .modal-actions { display:flex; justify-content:flex-end; gap:8px; }
      .modal-btn { padding:6px 12px; border-radius:8px; border:1px solid transparent; cursor:pointer; font-size:13px; }
      .modal-btn.save { background:#2563eb; color:#fff; border-color:#1d4ed8; }
      .modal-btn.save:hover { background:#1d4ed8; }
      .modal-btn.cancel { background:#f3f4f6; color:#374151; border-color:#d1d5db; }
      .modal-btn.cancel:hover { background:#e5e7eb; }
    `;

    const wrap = document.createElement('div');
    wrap.className = 'wrap';
    wrap.innerHTML = `
      <div class="app">
        <div class="card sidebar">
          <div class="side-head">
            <div style="font-weight:600;">对话</div>
            <button class="btn" id="newChat">新建</button>
          </div>
          <div class="search"><input id="q" placeholder="搜索会话…" /></div>
          <div class="list" id="list"></div>
        </div>
        <div class="card main">
          <div class="head">
            <div class="title" id="title">请选择会话</div>
            <div class="model-selector">
              <button class="system-btn" id="systemPromptBtn" title="设置系统提示词">系统提示词</button>
              <label for="modelSelect">模型:</label>
              <select id="modelSelect">
                <option value="gpt-5">GPT-5</option>
                <option value="claude-opus-4-1-20250805">Claude Opus 4.1</option>
                <option value="claude-opus-4-20250514">Claude Opus 4</option>
                <option value="claude-sonnet-4-20250514" selected>Claude Sonnet 4</option>
                <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                <option value="deepseek-v3.1">DeepSeek V3.1</option>
              </select>
            </div>

          </div>
          <div class="msgs" id="msgs"></div>
          <div class="foot">
            <div class="input">
              <div class="upload-btn" id="uploadBtn" title="上传文件">
                📁
                <input type="file" class="file-input" id="fileInput" accept=".txt,.md,.py,.js,.ts,.html,.css,.json,text/*">
                <div class="file-info" id="fileInfo" style="display: none;"></div>
                <div class="file-clear" id="fileClear" style="display: none;">×</div>
              </div>
              <textarea id="input" placeholder="Shift+Enter 换行；Enter 发送 / 生成中按 Enter 停止"></textarea>
              <button class="send" id="send">发送</button>
            </div>
          </div>
        </div>
      </div>
    `;

    // 创建背景模糊层
    const backdrop = document.createElement('div');
    backdrop.className = 'backdrop';

    // 点击背景不关闭面板，保持打开状态
    // backdrop.onclick = () => toggleUI(false);

    root.shadowRoot.append(style, backdrop, wrap);
    document.documentElement.appendChild(root);

    // 注入导航栏按钮
    injectNavButton();

    // refs
    const $ = sel => root.shadowRoot.querySelector(sel);
    $sidebar = $('#list'); $messages = $('#msgs'); $input = $('#input'); $send = $('#send'); $usage = $('#usage'); $title = $('#title');
    const $modelSelect = $('#modelSelect');
    const $systemPromptBtn = $('#systemPromptBtn');

    // 初始化模型选择器
    initModelSelector($modelSelect);

    if ($systemPromptBtn) {
      updateSystemPromptButton($systemPromptBtn);
      $systemPromptBtn.addEventListener('click', () => {
        openPromptModal();
      });
    } else {
      updateSystemPromptButton();
    }

    // 测试模型选择器功能
    setTimeout(() => {
      const currentModel = getCurrentModel();
      const displayName = getModelDisplayName(currentModel);
      console.log(`[模型选择器] 测试 - 当前模型: ${displayName}`);
      console.log(`[模型选择器] 测试 - 选择器值: ${$modelSelect.value}`);
      console.log(`[提示词] 当前系统提示词${customSystemPrompt ? '已设置' : '为空'}`);
    }, 500);

     $('#newChat').onclick = () => createConversation();

    $send.onclick = onSendButtonClick;
    updateSendButtonUI();

    // 文件上传功能
    const $uploadBtn = $('#uploadBtn');
    const $fileInput = $('#fileInput');
    const $fileInfo = $('#fileInfo');
    const $fileClear = $('#fileClear');

    // 全局文件UI更新函数
    window.updateFileUI = function() {
      if (state.uploadedFile) {
        $uploadBtn.classList.add('has-file');
        $uploadBtn.title = `已加载: ${state.uploadedFile.name}`;
        $fileInfo.textContent = state.uploadedFile.name;
        $fileInfo.style.display = 'block';
        $fileClear.style.display = 'block';
      } else {
        $uploadBtn.classList.remove('has-file');
        $uploadBtn.title = '上传文件';
        $fileInfo.style.display = 'none';
        $fileClear.style.display = 'none';
      }
    };

    $uploadBtn.onclick = () => $fileInput.click();
    $fileInput.addEventListener('change', handleFileUpload);
    $fileClear.onclick = clearFile;

    function handleFileUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        state.uploadedFile = {
          name: file.name,
          content: event.target.result
        };
        window.updateFileUI();
      };
      reader.onerror = () => {
        alert('读取文件失败！');
        clearFile();
      };
      reader.readAsText(file);
    }

    function clearFile() {
      state.uploadedFile = null;
      $fileInput.value = '';
      window.updateFileUI();
    }

    function updateFileUI() {
      window.updateFileUI();
    }

    // Enter 发送 / 停止
    $input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        onSendButtonClick();
      }
    });

    // 代码块复制（事件委托，兼容流式插入）
    $messages.addEventListener('click', async (e) => {
      const btn = e.target.closest('.copy-code');
      if (!btn) return;
      const raw = decodeURIComponent(btn.getAttribute('data-raw') || '');
      try { await navigator.clipboard.writeText(raw); btn.textContent = '已复制'; setTimeout(()=>btn.textContent='复制', 1100); } catch {}
    });

    // 代码块展开折叠（事件委托，兼容流式插入）
    $messages.addEventListener('click', (e) => {
      const btn = e.target.closest('.toggle-code');
      if (!btn) return;

      console.log('[折叠功能] 点击了折叠按钮', btn);
      const codeWrap = btn.closest('.code-wrap');
      if (!codeWrap) {
        console.log('[折叠功能] 找不到code-wrap');
        return;
      }

      const codeBlock = codeWrap.querySelector('.code-block');
      if (!codeBlock) {
        console.log('[折叠功能] 找不到code-block');
        return;
      }

      if (codeBlock.classList.contains('collapsed')) {
        codeBlock.classList.remove('collapsed');
        btn.textContent = '折叠';
        console.log('[折叠功能] 展开代码块');
      } else {
        codeBlock.classList.add('collapsed');
        btn.textContent = '展开';
        console.log('[折叠功能] 折叠代码块');
      }
    });

    // 初始化智能滚动跟踪
    initScrollTracking();
  }
  // 注入导航栏按钮
  function injectNavButton() {
    // 等待网站导航栏加载
    const waitForNav = setInterval(() => {
      const navContainer = document.querySelector('nav.hidden.lg\\:flex');
      if (navContainer) {
        clearInterval(waitForNav);

        // 创建聊天面板按钮
        const chatButton = document.createElement('a');
        chatButton.className = 'relative px-3 py-2 text-sm font-medium transition-colors rounded-sm outline-none focus-visible:ring-2 focus-visible:ring-foreground focus-visible:ring-offset-2 text-muted-foreground hover:text-foreground cursor-pointer';
        chatButton.textContent = '对话面板';
        chatButton.onclick = (e) => {
          e.preventDefault();
          toggleUI();
        };

        // 插入到"学习"后面
        navContainer.appendChild(chatButton);

        console.log('[导航集成] 聊天面板按钮已添加到导航栏');
      }
    }, 100);

    // 10秒后停止尝试
    setTimeout(() => clearInterval(waitForNav), 10000);
  }

  function toggleUI(force) {
    if (!root) return;
    const wrap = root.shadowRoot.querySelector('.wrap');
    const backdrop = root.shadowRoot.querySelector('.backdrop');

    const isVisible = typeof force === 'boolean' ? force : (wrap.style.display !== 'block');

    if (isVisible) {
      wrap.style.display = 'block';
      backdrop.style.display = 'block';
      console.log('[导航集成] 聊天面板已打开');
    } else {
      wrap.style.display = 'none';
      backdrop.style.display = 'none';
      console.log('[导航集成] 聊天面板已关闭');
    }
  }
  document.addEventListener('keydown', (e) => {
    // ESC键关闭面板
    if (e.key === 'Escape') {
      const wrap = root?.shadowRoot?.querySelector('.wrap');
      if (wrap && wrap.style.display === 'block') {
        toggleUI(false);
        e.preventDefault();
      }
    }
    // 原有快捷键
    if (!!e.ctrlKey === !!UI_HOTKEY.ctrlKey && !!e.altKey === !!UI_HOTKEY.altKey && e.key.toLowerCase() === UI_HOTKEY.key) {
      toggleUI();
    }
  });

  /** ========= 渲染 ========= **/
  function renderSidebar(filter='') {
    if (!$sidebar) return;
    const items = Object.values(state.conversations).sort((a,b)=> (b.updatedAt||'').localeCompare(a.updatedAt||''));
    $sidebar.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (const c of items) {
      if (filter && !((c.title||'')+JSON.stringify(c.messages)).includes(filter)) continue;
      const div = document.createElement('div');
      div.className = 'item' + (state.activeId === c.id ? ' active' : '');

      // 使用innerHTML来显示标题和日期
      const title = c.title || '未命名';
      const safeTitle = escHtml(title);
      const date = formatDate(c.createdAt || c.updatedAt);
      const safeDate = escHtml(date);
      div.innerHTML = `
        <div class="item-main">
          <span class="item-title">${safeTitle}</span>
          <span class="item-icons">
            <button class="item-icon rename" title="重命名" aria-label="重命名">✏️</button>
            <button class="item-icon delete" title="删除" aria-label="删除">🗑️</button>
          </span>
        </div>
        <div class="item-date">${safeDate}</div>
      `;

      div.onclick = () => {
        state.activeId = c.id;
        // 切换对话时重置滚动状态，避免闪现
        userScrolledAway = false;
        saveStore(); renderSidebar(); renderMessages(); renderHeader();
        updateSendButtonUI(); // 切换会话时更新按钮

        console.log(`[会话切换] 切换到会话: ${c.id}`);
      };
      const renameBtn = div.querySelector('.item-icon.rename');
      const deleteBtn = div.querySelector('.item-icon.delete');
      if (renameBtn) {
        renameBtn.onclick = (evt) => {
          evt.stopPropagation();
          startInlineRename(div, c);
        };
      }
      if (deleteBtn) {
        deleteBtn.onclick = (evt) => {
          evt.stopPropagation();
          handleItemDelete(div, c.id, deleteBtn);
        };
      }
      frag.appendChild(div);
    }
    $sidebar.appendChild(frag);
    const $q = root.shadowRoot.querySelector('#q');
    if ($q && !$q._bound) {
      $q._bound = true;
      $q.addEventListener('input', () => renderSidebar($q.value.trim()));
    }
    updateSystemPromptButton();
  }
  function renderHeader() {
    const c = state.conversations[state.activeId || ''] || null;
    if ($title) $title.textContent = c ? (c.title || '未命名') : '请选择会话';
  }
  function scrollToBottom() {
    if (!$messages) return;

    // 检查用户是否接近底部（容忍50px的误差）
    const isNearBottom = $messages.scrollTop + $messages.clientHeight >= $messages.scrollHeight - 50;

    // 只有在用户接近底部时才自动滚动
    if (isNearBottom) {
      $messages.scrollTop = $messages.scrollHeight + 9999;
    }
  }

  // 添加用户滚动状态跟踪
  let userScrolledAway = false;

  function initScrollTracking() {
    if (!$messages) return;

    $messages.addEventListener('scroll', () => {
      const isNearBottom = $messages.scrollTop + $messages.clientHeight >= $messages.scrollHeight - 50;
      userScrolledAway = !isNearBottom;
    });
  }

  // 智能滚动函数 - 只在用户没有手动上滑时滚动，优化无闪现滚动
  function smartScrollToBottom() {
    if (!$messages || userScrolledAway) return;
    // 使用 requestAnimationFrame 替代 setTimeout 减少闪现
    requestAnimationFrame(() => {
      if (!userScrolledAway) {
        $messages.scrollTop = $messages.scrollHeight;
      }
    });
  }

  function renderMessages() {
    if (!$messages) return;
    $messages.innerHTML = '';
    const c = state.conversations[state.activeId || ''];
    if (!c) return;

    c.messages.forEach((m, idx) => {
      const d = document.createElement('div');
      d.className = 'bubble ' + (m.role === 'user' ? 'user' : 'assistant');
      const status = m.status === 'stopped' ? `<span class="status">已中断</span>` : '';
      // 显示模型名称而不是 "assistant"
      const roleDisplay = m.role === 'assistant' ? (getModelShortName(m.model) || 'Assistant') : m.role;
      d.innerHTML = `
        <div class="content">${renderMD(m.content)}</div>
        <div class="meta">
          <span>${roleDisplay} · ${new Date(m.ts||nowISO()).toLocaleTimeString()} ${status}</span>
          <div class="tools">
            <span class="tool copy">复制</span>
            <span class="tool del">删除</span>
            ${m.role === 'assistant' ? `<span class="tool regen">重新生成</span>${m.status==='stopped'?`<span class="tool resume">继续</span>`:''}` : ''}
            ${m.role === 'user' ? `<span class="tool resend">重发</span>` : ''}
          </div>
        </div>`;

      // 工具
      d.querySelector('.tool.copy').onclick = async ()=>{ try{ await navigator.clipboard.writeText(m.content||''); }catch{} };
      d.querySelector('.tool.del').onclick  = ()=>{ c.messages.splice(idx,1); c.updatedAt=nowISO(); saveStore(); renderMessages(); renderSidebar(); };
      const regen = d.querySelector('.tool.regen');
      const resend = d.querySelector('.tool.resend');
      const resume = d.querySelector('.tool.resume');
      if (regen)  regen.onclick  = ()=> regenerateAssistantAt(idx);
      if (resend) resend.onclick = ()=> resendUserAt(idx);
      if (resume) resume.onclick = ()=> resumeAssistantAt(idx);

      $messages.appendChild(d);

      // 对助手消息应用动态折叠检测
      if (m.role === 'assistant') {
        setTimeout(() => dynamicCodeBlockCollapse(d), 10);
      }
    });
    smartScrollToBottom();
  }

  /** ========= 输入/发送/停止（每会话独立） ========= **/
  async function onSendButtonClick() {
    const convId = state.activeId; if (!convId) return;
    const rt = getRT(convId);

    if (rt.isGenerating) {
      console.log(`[会话隔离] 停止会话 ${convId} 的生成`);
      // 停止请求
      if (rt.controller) { try { rt.controller.abort(); } catch {} }
      // 终止部分内容为停止状态
      finalizePartialAsStopped(convId);
      // 清理监听器
      cleanupListenerForConv(convId);
      // 重置状态
      rt.isGenerating = false;
      rt.controller = null;
      updateSendButtonUI();
      return;
    }
    await sendCurrent();
  }
  function updateSendButtonUI() {
    const convId = state.activeId; if (!convId || !$send) return;
    const rt = getRT(convId);
    if (rt.isGenerating) { $send.textContent = '停止'; $send.title = '正在生成，点击停止'; }
    else { $send.textContent = '发送'; $send.title = '发送消息'; }
  }

  async function sendCurrent() {
    const convId = state.activeId; if (!convId) { createConversation(); return; }

    console.log(`[并行对话] 开始会话 ${convId} 的新请求`);

    const c = state.conversations[convId];
    const text = ($input.value || '').trim(); if (!text) return;
    $input.value = '';

    // 用户消息
    const uMsg = { id: uid('m'), role:'user', content:text, ts: nowISO() };
    c.messages.push(uMsg);
    c.updatedAt = nowISO();
    if (!c.title || c.title === '新对话' || c.title === '未命名') c.title = text.slice(0, 20) || '未命名';
    saveStore(); renderSidebar(); renderMessages(); renderHeader();

    // 历史（OpenAI 形态）
    let history = c.messages.map(m => ({ role: m.role, content: m.content }));
    history = ensureGlobalSystem(history);
    if (INJECT_TO_FIRST_USER_TOO) history = injectToFirstUser(history);

    // runtime
    const rt = getRT(convId);
    rt.curAssistant = { node:null, content:'', targetIndex:null };

    // 监听器
    const l = buildListenerForStreaming(convId, c, null);
    bridge.listeners.add(l); bridge.order.push(l);
    rt.listener = l; rt.isGenerating = true; updateSendButtonUI();

    // 注入 & 触发
    window.__upstreamMessages = history;
    ensureAssistantBubble(convId);

    if (FAST_SEND) {
      const { controller } = await sendViaDirectFetch(convId, l.expectedRid);
      rt.controller = controller;
    } else {
      await submitMessageViaUI(text, { ifGenerating:'none' });
    }
  }

  function finalizePartialAsStopped(convId) {
    const c = state.conversations[convId||'']; if (!c) return;
    const rt = getRT(convId);
    const cur = rt.curAssistant;

    if (cur && (cur.content||'').trim()) {
      if (cur.targetIndex != null) {
        const t = c.messages[cur.targetIndex];
        if (t && t.role === 'assistant') { t.content = cur.content; t.status = 'stopped'; t.ts = nowISO(); }
      } else {
        c.messages.push({ id: uid('m'), role:'assistant', content: cur.content, ts: nowISO(), status:'stopped', model: getCurrentModel() });
      }
      c.updatedAt = nowISO();
      saveStore(); renderMessages();
    }
    rt.curAssistant = { node:null, content:'', targetIndex:null };
  }

  async function regenerateAssistantAt(index) {
    const convId = state.activeId; if (!convId) return;
    const c = state.conversations[convId||'']; if (!c) return;
    const rt = getRT(convId);
    if (rt.isGenerating) { alert('当前会话正在生成，请先停止或等待结束'); return; }
    const m = c.messages[index]; if (!m || m.role !== 'assistant') return;

    // 找到该助手之前最近 user
    let uIdx = -1;
    for (let i=index-1; i>=0; i--) { if (c.messages[i].role === 'user') { uIdx = i; break; } }
    if (uIdx === -1) { alert('未找到对应的用户消息，无法重新生成'); return; }

    // 历史到该 user（含）
    let history = c.messages.slice(0, uIdx+1).map(x => ({ role:x.role, content:x.content }));
    history = ensureGlobalSystem(history);
    if (INJECT_TO_FIRST_USER_TOO) history = injectToFirstUser(history);

    // 替换模式监听
    const l = buildListenerForStreaming(convId, c, index);
    bridge.listeners.add(l); bridge.order.push(l);
    rt.listener = l; rt.isGenerating = true; updateSendButtonUI();

    c.messages[index].content = '';
    c.messages[index].status = undefined;
    saveStore(); renderMessages();

    window.__upstreamMessages = history;
    rt.curAssistant = { node:null, content:'', targetIndex:index };

    if (FAST_SEND) {
      const { controller } = await sendViaDirectFetch(convId, l.expectedRid);
      rt.controller = controller;
    } else {
      await submitMessageViaUI(c.messages[uIdx].content, { ifGenerating:'none' });
    }
  }

  async function resumeAssistantAt(index) {
    const convId = state.activeId; if (!convId) return;
    const c = state.conversations[convId||'']; if (!c) return;
    const rt = getRT(convId);
    if (rt.isGenerating) { alert('当前会话正在生成，请先停止或等待结束'); return; }
    const m = c.messages[index]; if (!m || m.role !== 'assistant') return;

    const CONTINUE_HINT = '请从上次中断处继续输出，延续相同风格与结构，不要重复已给出的部分。';
    let history = c.messages.map(x => ({ role:x.role, content:x.content }));
    history = ensureGlobalSystem(history);
    history.push({ role:'system', content: CONTINUE_HINT });

    const l = buildListenerForStreaming(convId, c, null);
    bridge.listeners.add(l); bridge.order.push(l);
    rt.listener = l; rt.isGenerating = true; updateSendButtonUI();

    window.__upstreamMessages = history;
    rt.curAssistant = { node:null, content:'', targetIndex:null };
    ensureAssistantBubble(convId);

    if (FAST_SEND) {
      const { controller } = await sendViaDirectFetch(convId, l.expectedRid);
      rt.controller = controller;
    } else {
      await submitMessageViaUI('（继续）', { ifGenerating:'none' });
    }
  }

  async function resendUserAt(index) {
    const convId = state.activeId; if (!convId) return;
    const c = state.conversations[convId||'']; if (!c) return;
    const rt = getRT(convId);
    if (rt.isGenerating) { alert('当前会话正在生成，请先停止或等待结束'); return; }
    const m = c.messages[index]; if (!m || m.role !== 'user') return;

    c.messages = c.messages.slice(0, index+1);
    saveStore(); renderMessages();

    let history = c.messages.map(x => ({ role:x.role, content:x.content }));
    history = ensureGlobalSystem(history);
    if (INJECT_TO_FIRST_USER_TOO) history = injectToFirstUser(history);

    const l = buildListenerForStreaming(convId, c, null);
    bridge.listeners.add(l); bridge.order.push(l);
    rt.listener = l; rt.isGenerating = true; updateSendButtonUI();

    window.__upstreamMessages = history;
    rt.curAssistant = { node:null, content:'', targetIndex:null };
    ensureAssistantBubble(convId);

    if (FAST_SEND) {
      const { controller } = await sendViaDirectFetch(convId, l.expectedRid);
      rt.controller = controller;
    } else {
      await submitMessageViaUI(m.content, { ifGenerating:'none' });
    }
  }

  /** ========= 站点按钮（仅 UI 路径兜底用） ========= **/
  async function findChatInput(timeout = 6000) {
    let el = null;
    for (let i = 0; i < timeout/80; i++) {
      el = document.querySelector('textarea[aria-label="Chat message"]') ||
           document.querySelector('div[contenteditable="true"][data-placeholder]') ||
           document.querySelector('div[contenteditable="true"]');
      if (el) break;
      await new Promise(r => setTimeout(r, 80));
    }
    return el;
  }
  function setNativeValue(el, value) {
    const proto = el.__proto__ || Object.getPrototypeOf(el);
    const desc = Object.getOwnPropertyDescriptor(proto, 'value');
    const setter = desc && desc.set;
    const defaultSetter = (el.tagName === 'TEXTAREA'
      ? Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value')
      : Object.getPropertyDescriptor?.(HTMLInputElement.prototype, 'value')?.set
    );
    (setter || defaultSetter)?.call(el, value);
  }
  async function submitMessageViaUI(userText, { timeoutMs = 6000 } = {}) {
    const inputEl = await findChatInput(timeoutMs);
    if (!inputEl) throw new Error('未找到聊天输入框');
    inputEl.focus();
    if (inputEl.tagName === 'TEXTAREA' || inputEl instanceof HTMLTextAreaElement) setNativeValue(inputEl, userText||'');
    else if (inputEl.isContentEditable) { inputEl.innerHTML=''; inputEl.appendChild(document.createTextNode(userText||'')); }
    else setNativeValue(inputEl, userText||'');
    inputEl.dispatchEvent(new Event('input', { bubbles:true }));
    inputEl.dispatchEvent(new Event('change',{ bubbles:true }));

    const btnSel = 'button[type="submit"][data-slot="button"], button[type="submit"]';
    let btn = document.querySelector(btnSel);
    if (btn && !btn.disabled) { try { btn.click(); return; } catch{} }
    try {
      const kd = new KeyboardEvent('keydown', { key:'Enter', code:'Enter', which:13, keyCode:13, bubbles:true });
      const ku = new KeyboardEvent('keyup',   { key:'Enter', code:'Enter', which:13, keyCode:13, bubbles:true });
      inputEl.dispatchEvent(kd); inputEl.dispatchEvent(ku);
    } catch {}
  }

  /** ========= fetch 拦截：构造 Cursor 体 + SSE 按 rid 分发 ========= **/
  const prevFetch = window.fetch.bind(window);
  const bridge = { listeners: new Set(), order: [] };
  window.emitMeta  = (meta) => {
    const rid = meta?.rid; if (!rid) return;
    console.log(`[并行对话] 收到元数据，rid=${rid}`);

    // 优先查找预期rid匹配的监听器
    for (const l of bridge.listeners) {
      if (l.expectedRid === rid && !l.rid) {
        l.rid = rid;
        l.active = true;
        console.log(`[并行对话] 匹配监听器，会话=${l.convId}, rid=${rid}`);
        return;
      }
    }

    // 回退到原来的逻辑（从后往前找）
    for (let i=bridge.order.length-1;i>=0;i--){
      const l=bridge.order[i];
      if (!l.rid){
        l.rid=rid;
        l.active=true;
        console.log(`[并行对话] 回退匹配监听器，会话=${l.convId}, rid=${rid}`);
        break;
      }
    }
  };
  window.emitDelta = (rid, d) => {
    for (const l of bridge.listeners) if (l.active && l.rid === rid) { try { l.onDelta && l.onDelta(d); } catch{} }
  };
  window.emitDone  = (rid) => {
    for (const l of bridge.order) if (l.rid === rid && l.active) { try { l.onDone && l.onDone(); } catch{} l.active=false; break; }
  };
  window.emitUsage = (rid, u) => {
    for (const l of bridge.listeners) if (l.active && l.rid === rid) { try { l.onUsage && l.onUsage(u); } catch{} }
  };

  const ridPrefix = 'RID_' + Math.random().toString(16).slice(2) + '_'; let ridSeq=0;

  function toCursorMessages(listOpenAI) {
    return (listOpenAI || []).map(m => ({
      role: m.role,
      parts: [{ type: 'text', text: String(m.content ?? '') }],
    }));
  }
  function buildCursorBody({ messagesOpenAI, model, rid }) {
    const selectedModel = model || getCurrentModel();
    return {
      context: [],
      model: selectedModel,
      id: rid || ('req_' + Math.random().toString(16).slice(2)),
      messages: toCursorMessages(messagesOpenAI),
      trigger: 'submit-message',
      __mergedUpstream: true,
      __rid: rid,
    };
  }

  async function readBodyAsText(input, init) {
    if (input && typeof input === 'object' && input instanceof Request) {
      try { return await input.clone().text(); } catch { return null; }
    }
    const body = init && init.body;
    if (body == null) return null;
    if (typeof body === 'string') return body;
    if (body instanceof Blob) { try { return await body.text(); } catch { return null; } }
    if (body instanceof URLSearchParams) return body.toString();
    if (body instanceof FormData) return null;
    if (body instanceof ArrayBuffer) { try { return new TextDecoder().decode(body); } catch { return null; } }
    if (ArrayBuffer.isView(body)) { try { return new TextDecoder().decode(body.buffer); } catch { return null; } }
    return null;
  }
  function rebuildArgsWithBody(input, init, jsonStr) {
    const headers = new Headers((input && input.headers) || (init && init.headers) || {});
    headers.set('content-type', 'application/json; charset=utf-8');
    if (input instanceof Request) {
      const url = input.url;
      const reqInit = {
        method: (init && init.method) || input.method || 'POST',
        headers, body: jsonStr,
        mode: input.mode, credentials: input.credentials, cache: input.cache,
        redirect: input.redirect, referrer: input.referrer, referrerPolicy: input.referrerPolicy,
        integrity: input.integrity, keepalive: input.keepalive, signal: (init && init.signal) || input.signal,
      };
      return [new Request(url, reqInit), undefined];
    } else {
      const newInit = Object.assign({}, init, { headers, body: jsonStr, method: (init && init.method) || 'POST' });
      return [input, newInit];
    }
  }

  if (!prevFetch.__overlayInstalled) {
    window.fetch = async function(...args){
      let [input, init = {}] = args;
      const url = typeof input === 'string' ? input : input?.url || '';
      const method = (init?.method || (input instanceof Request ? input.method : 'GET') || 'GET').toUpperCase();
      const isChat = url.includes('/api/chat') && method === 'POST';

      let knownRid = null; // ★ 为这次请求记住 rid（供 SSE 路由）

      if (isChat) {
        try {
          const raw = await readBodyAsText(input, init);
          if (raw) {
            let body; try { body = JSON.parse(raw); } catch {}
            if (body && typeof body === 'object') {
              // 统一得到 OpenAI 形态历史
              const current = Array.isArray(body.messages) ? body.messages : [];
              let msgsOpenAI = current.map(m => ({ role:m.role, content: readText(m) }));

              // 强制覆盖为 upstream
              if (FORCE_OVERRIDE_ON_UPSTREAM && Array.isArray(window.__upstreamMessages)) {
                msgsOpenAI = window.__upstreamMessages.map(m => ({ role: m.role, content: readText(m) }));
              }

              // 注入 system / 可选首 user 前缀
              msgsOpenAI = ensureGlobalSystem(msgsOpenAI);
              if (INJECT_TO_FIRST_USER_TOO) msgsOpenAI = injectToFirstUser(msgsOpenAI);

              // 注入文件内容（如果存在）
              if (state.uploadedFile && state.uploadedFile.content) {
                console.log(`[文件注入] 注入文件: ${state.uploadedFile.name}`);
                const fileMessage = {
                  role: 'user',
                  content: `文件名: ${state.uploadedFile.name}\n\n${state.uploadedFile.content}`
                };
                // 在最后一条消息前插入文件
                msgsOpenAI.splice(msgsOpenAI.length - 1, 0, fileMessage);
                // 发送后立即清除文件
                state.uploadedFile = null;
                // 更新UI
                if (window.updateFileUI) window.updateFileUI();
              }

              // rid + meta（无条件 emit）
              const rid = body.__rid || (ridPrefix + (++ridSeq));
              knownRid = rid;
              try { window.emitMeta && window.emitMeta({ rid }); } catch {}

              // model - 使用用户选择的模型
              const modelName = body.model || getCurrentModel();
              console.log(`[模型选择] 使用模型: ${modelName}`);

              // 构造 Cursor 体
              const cursorBody = buildCursorBody({ messagesOpenAI: msgsOpenAI, model: modelName, rid });

              // 写回
              const jsonStr = JSON.stringify(cursorBody);
              [input, init] = rebuildArgsWithBody(input, init, jsonStr);
            }
          }
        } catch (e){ log('rewrite failed', e); }
      }

      const resp = await prevFetch(input, init);

      if (isChat) {
        try {
          const clone = resp.clone();
          if (clone.body) (async () => {
            const reader = clone.body.getReader();
            const decoder = new TextDecoder();
            let buf = '';

            const flush = async (chunk) => {
              const dataLines = chunk.split(/\r?\n/).filter(l => l.startsWith('data:'));
              const dataStr = dataLines.map(l => l.replace(/^data:\s?/, '')).join('\n').trim();
              if (!dataStr) return;
              if (dataStr === '[DONE]') { if (knownRid) window.emitDone(knownRid); return; }
              let evt; try { evt = JSON.parse(dataStr); } catch { return; }

              if (evt?.type === 'text-delta' && typeof evt.delta === 'string') {
                if (knownRid) window.emitDelta(knownRid, evt.delta);
              }
              const u = evt?.messageMetadata?.usage;
              if (u && knownRid) window.emitUsage(knownRid, u);
              if (evt?.type === 'text-end' || evt?.type === 'finish-step' || evt?.type === 'finish') {
                if (knownRid) window.emitDone(knownRid);
              }
            };

            while (true) {
              const { value, done } = await reader.read();
              if (done) { if (knownRid) window.emitDone(knownRid); break; }
              buf += decoder.decode(value, { stream:true });
              let idx;
              while ((idx = buf.indexOf('\n\n')) !== -1) {
                const frame = buf.slice(0, idx);
                buf = buf.slice(idx + 2);
                await flush(frame);
              }
            }
          })();
        } catch (e){ log('sse parse failed', e); }
      }
      return resp;
    };
    window.fetch.__overlayInstalled = true;
  }

  /** ========= 直连发送（返回 controller，供 per-conv 停止） ========= **/
  async function sendViaDirectFetch(convId, preAssignedRid) {
    const controller = new AbortController();
    const rid = preAssignedRid || ('RID_' + Math.random().toString(16).slice(2));
    const selectedModel = getCurrentModel();
    const body = {
      context: [],
      model: selectedModel,
      id: 'req_' + Math.random().toString(16).slice(2),
      messages: [], // 历史由拦截器填
      trigger: 'submit-message',
      __mergedUpstream: true,
      __rid: rid
    };

    console.log(`[并行对话] 发送请求，会话=${convId}, rid=${rid}, 模型=${selectedModel}`);

    await fetch('/api/chat', {
      method:'POST',
      headers:{'content-type':'application/json'},
      body: JSON.stringify(body),
      signal: controller.signal
    });
    return { controller, rid };
  }

  /** ========= 实时气泡（按会话缓冲） ========= **/
  function ensureAssistantBubble(convId) {
    const rt = getRT(convId);
    if (rt.curAssistant.node) return;
    const d = document.createElement('div');
    d.className = 'bubble assistant';
    // 显示当前模型名称而不是 "assistant"
    const currentModelName = getModelShortName(getCurrentModel()) || 'Assistant';
    d.innerHTML = `<div class="content">…</div><div class="meta"><span>${currentModelName} · ${new Date().toLocaleTimeString()}</span></div>`;
    $messages.appendChild(d);
    rt.curAssistant.node = d;
    smartScrollToBottom();
  }
  function redrawAssistantBubble(convId) {
    const rt = getRT(convId);
    if (!rt.curAssistant.node) return;
    rt.curAssistant.node.querySelector('.content').innerHTML = renderMD(rt.curAssistant.content || '');

    // 防抖式动态检测和更新代码块折叠状态（避免频繁调用造成闪动）
    if (rt.collapseTimer) {
      clearTimeout(rt.collapseTimer);
    }
    rt.collapseTimer = setTimeout(() => {
      dynamicCodeBlockCollapse(rt.curAssistant.node);
      rt.collapseTimer = null;
    }, 100); // 100ms防抖延迟

    smartScrollToBottom();
  }
  function redrawAssistantBubbleAt(index, text) {
    const c = state.conversations[state.activeId||'']; if (!c) return;
    c.messages[index].content = text;
    renderMessages(); // 简化处理，保持索引正确

    // 在重新渲染后也检查动态折叠
    setTimeout(() => {
      const bubbles = $messages.querySelectorAll('.bubble.assistant');
      if (bubbles[index]) {
        dynamicCodeBlockCollapse(bubbles[index]);
      }
    }, 10);
  }

  // 动态检测代码块是否需要折叠（流式渲染时使用）
  function dynamicCodeBlockCollapse(node) {
    if (!node) return;

    const codeBlocks = node.querySelectorAll('.code-wrap');
    codeBlocks.forEach(codeWrap => {
      const codeElement = codeWrap.querySelector('.code-block code');
      const preElement = codeWrap.querySelector('.code-block');
      const headButtons = codeWrap.querySelector('.code-buttons');
      const existingToggle = headButtons?.querySelector('.toggle-code');

      if (!codeElement || !preElement) return;

      // 优先使用data-lines属性，然后计算实际行数
      let lines = parseInt(codeWrap.getAttribute('data-lines')) || 0;

      if (!lines) {
        // 计算实际行数 - 使用总行数保持一致
        let codeText = codeElement.innerHTML || codeElement.textContent || '';
        // 解码 HTML 实体以获得准确的行数
        codeText = codeText.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
        // 使用总行数
        lines = codeText.split('\n').length;
        // 更新data-lines属性
        codeWrap.setAttribute('data-lines', lines);
      }

      const isLong = lines >= 5; // 5行或以上就折叠
      const hasToggle = !!existingToggle;
      const isCollapsed = preElement.classList.contains('collapsed');

      // 记录当前状态用于状态变更检查
      const currentState = { isLong, hasToggle, isCollapsed };
      const lastState = codeWrap._lastCollapseState || {};

      // 只有当状态确实需要改变时才进行DOM操作（避免不必要的重绘）
      if (JSON.stringify(currentState) === JSON.stringify(lastState)) {
        return; // 状态未变化，跳过
      }

      codeWrap._lastCollapseState = currentState;
      console.log(`[动态折叠] 代码块状态变更: ${lines}行, 需要折叠=${isLong}, 有按钮=${hasToggle}, 已折叠=${isCollapsed}`);

      if (isLong && !hasToggle) {
        // 需要折叠但还没有按钮，添加折叠按钮和状态
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'toggle-code';
        toggleBtn.textContent = '展开';
        toggleBtn.title = '展开/折叠';
        headButtons?.appendChild(toggleBtn);

        // 设置为折叠状态
        if (!isCollapsed) {
          preElement.classList.add('collapsed');
        }
      } else if (!isLong && hasToggle) {
        // 不需要折叠但有按钮，移除按钮和折叠状态
        existingToggle.remove();
        preElement.classList.remove('collapsed');
      } else if (isLong && hasToggle && !isCollapsed) {
        // 已经有折叠功能但未折叠，确保处于折叠状态
        preElement.classList.add('collapsed');
        if (existingToggle.textContent !== '展开') {
          existingToggle.textContent = '展开';
        }
      }
    });
  }

  /** ========= 流监听（带 convId） ========= **/
  function buildListenerForStreaming(convId, conversation, replaceIndex) {
    const rt = getRT(convId);
    // 预分配 rid，确保每个监听器有唯一标识
    const preAssignedRid = ridPrefix + (++ridSeq);

    const l = {
      rid: null, // 仍然由 emitMeta 最终分配，但我们记录预期的 rid
      expectedRid: preAssignedRid,
      active: false,
      closed: false,
      convId,
      onDelta: (d) => {
        if (replaceIndex != null) {
          const target = conversation.messages[replaceIndex];
          if (!target || target.role !== 'assistant') return;
          target.content = (target.content || '') + d;
          redrawAssistantBubbleAt(replaceIndex, target.content);
        } else {
          ensureAssistantBubble(convId);
          rt.curAssistant.content += d;
          redrawAssistantBubble(convId); // 实时渲染 MD
        }
        $usage.textContent = '生成中…';
      },
      onUsage: (u) => { $usage.textContent = `usage: in=${u?.inputTokens||0} out=${u?.outputTokens||0} total=${u?.totalTokens||0}`; },
      onDone: () => {
        if (replaceIndex != null) {
          conversation.messages[replaceIndex].status = undefined;
          conversation.messages[replaceIndex].ts = nowISO();
        } else {
          conversation.messages.push({ id: uid('m'), role:'assistant', content: rt.curAssistant.content, ts: nowISO(), model: getCurrentModel() });
          rt.curAssistant = { node:null, content:'', targetIndex:null };
        }
        conversation.updatedAt = nowISO();
        saveStore(); renderMessages();

        // 正确清理监听器
        cleanupListenerForConv(convId);
        rt.isGenerating = false;
        rt.controller = null;
        if (state.activeId === convId) updateSendButtonUI();

        console.log(`[并行对话] 会话 ${convId} 生成完成，清理监听器`);
      }
    };

    console.log(`[并行对话] 创建监听器，会话=${convId}, 预期rid=${preAssignedRid}`);
    return l;
  }

  /** ========= 启动 ========= **/
  function start() {
    loadCustomPrompt();
    injectUI();
    loadStore();
    updateSystemPromptButton();
    if (!state.activeId) createConversation();
    renderSidebar(); renderMessages(); renderHeader(); updateSendButtonUI();

    // 自动打开聊天面板
    setTimeout(() => {
      toggleUI(true);
      console.log('[导航集成] 自动打开聊天面板');
    }, 1000);
  }

  // 尝试展开站点侧栏，避免挡住
  setTimeout(() => {
    const candidates = [
      'button[title="Expand Chat Sidebar"]',
      'button:has(svg.lucide-panel-right-open)',
      'div.absolute.top-1\\/2.left-1\\/2.-translate-x-1\\/2.-translate-y-1\\/2.transform button[data-slot="button"][title="Expand Chat Sidebar"]',
    ];
    for (const sel of candidates) {
      const el = document.querySelector(sel);
      if (el && !el.disabled) { try { el.click(); break; } catch{} }
    }
  }, 800);

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', start);
  else start();

  function startInlineRename(itemEl, conversation) {
    if (!itemEl || !conversation) return;
    if (itemEl.classList.contains('editing')) return;

    const titleSpan = itemEl.querySelector('.item-title');
    if (!titleSpan) return;

    itemEl.classList.add('editing');

    const input = document.createElement('input');
    input.type = 'text';
    input.value = conversation.title || '未命名';
    input.className = 'item-rename-input';
    titleSpan.replaceWith(input);
    input.focus();
    input.select();

    let finished = false;
    const finish = (commit) => {
      if (finished) return;
      finished = true;

      const originalTitle = conversation.title || '未命名';
      const nextTitle = commit ? (input.value || '').trim() : originalTitle;
      const finalTitle = nextTitle || '未命名';

      itemEl.classList.remove('editing');

      if (commit && finalTitle !== originalTitle) {
        renameConversation(conversation.id, finalTitle);
      } else {
        renderSidebar();
      }
    };

    input.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        finish(true);
      } else if (event.key === 'Escape') {
        event.preventDefault();
        finish(false);
      }
    });
    input.addEventListener('blur', () => finish(true));
  }

  function resetDeleteConfirm(btn) {
    if (!btn) return;
    if (btn._confirmTimer) {
      clearTimeout(btn._confirmTimer);
      btn._confirmTimer = null;
    }
    delete btn.dataset.confirm;
    btn.classList.remove('confirm');
    btn.textContent = '🗑️';
    btn.title = '删除';
    btn.setAttribute('aria-label', '删除');
  }

  function handleItemDelete(itemEl, convId, btn) {
    if (!btn) return;
    if (btn.dataset.confirm === 'yes') {
      resetDeleteConfirm(btn);
      deleteConversation(convId);
      return;
    }

    btn.dataset.confirm = 'yes';
    btn.classList.add('confirm');
    btn.textContent = '✔';
    btn.title = '确认删除';
    btn.setAttribute('aria-label', '确认删除');
    btn._confirmTimer = setTimeout(() => resetDeleteConfirm(btn), 2200);
  }

  function loadCustomPrompt() {
    try {
      const stored = localStorage.getItem(CUSTOM_PROMPT_KEY);
      customSystemPrompt = stored ? String(stored) : '';
    } catch (err) {
      customSystemPrompt = '';
    }
  }

  function saveCustomPrompt(prompt) {
    customSystemPrompt = prompt || '';
    try {
      localStorage.setItem(CUSTOM_PROMPT_KEY, customSystemPrompt);
    } catch (err) {
      console.warn('[提示词] 无法写入 localStorage', err);
    }
    updateSystemPromptButton();
  }

  function getGlobalInstruction() {
    const extra = customSystemPrompt ? `${customSystemPrompt}\n` : '';
    return extra + BASE_GLOBAL_INSTRUCTION;
  }

  function updateSystemPromptButton(btn) {
    const button = btn || (root?.shadowRoot?.querySelector('#systemPromptBtn'));
    if (!button) return;
    const hasPrompt = !!customSystemPrompt;
    button.textContent = hasPrompt ? '系统提示词*' : '系统提示词';
    button.title = hasPrompt ? '系统提示词（已设置）' : '设置系统提示词';
  }

  function openPromptModal() {
    if (!root || !root.shadowRoot) return;
    const shadow = root.shadowRoot;
    const existing = shadow.querySelector('.modal-backdrop.prompt-modal');
    if (existing) existing.remove();

    const backdrop = document.createElement('div');
    backdrop.className = 'modal-backdrop prompt-modal';

    const card = document.createElement('div');
    card.className = 'modal-card';

    const title = document.createElement('h3');
    title.textContent = '系统提示词';

    const desc = document.createElement('p');
    desc.textContent = '设置后会自动追加到默认指令之前，可留空。';

    const textarea = document.createElement('textarea');
    textarea.placeholder = '在此输入系统提示词（可多行，保存后生效）';
    textarea.value = customSystemPrompt || '';

    const actions = document.createElement('div');
    actions.className = 'modal-actions';

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'modal-btn cancel';
    cancelBtn.textContent = '取消';

    const saveBtn = document.createElement('button');
    saveBtn.className = 'modal-btn save';
    saveBtn.textContent = '保存';

    const close = () => {
      if (backdrop.isConnected) backdrop.remove();
    };

    cancelBtn.addEventListener('click', () => close());
    backdrop.addEventListener('click', (event) => {
      if (event.target === backdrop) close();
    });

    saveBtn.addEventListener('click', () => {
      const value = textarea.value.trim();
      saveCustomPrompt(value);
      close();
      console.log('[提示词] 已更新');
    });

    textarea.addEventListener('keydown', (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
        event.preventDefault();
        saveBtn.click();
      }
    });

    actions.append(cancelBtn, saveBtn);
    card.append(title, desc, textarea, actions);
    backdrop.appendChild(card);
    shadow.appendChild(backdrop);

    setTimeout(() => textarea.focus(), 0);
  }

})();
